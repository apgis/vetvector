[
    {
        "label": "Flask",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "request",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "jsonify",
        "importPath": "flask",
        "description": "flask",
        "isExtraImport": true,
        "detail": "flask",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "tensorflow.keras.models",
        "description": "tensorflow.keras.models",
        "isExtraImport": true,
        "detail": "tensorflow.keras.models",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "tensorflow.keras.models",
        "description": "tensorflow.keras.models",
        "isExtraImport": true,
        "detail": "tensorflow.keras.models",
        "documentation": {}
    },
    {
        "label": "load_model",
        "importPath": "tensorflow.keras.models",
        "description": "tensorflow.keras.models",
        "isExtraImport": true,
        "detail": "tensorflow.keras.models",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "tensorflow",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tensorflow",
        "description": "tensorflow",
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "keras",
        "importPath": "tensorflow",
        "description": "tensorflow",
        "isExtraImport": true,
        "detail": "tensorflow",
        "documentation": {}
    },
    {
        "label": "pickle",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pickle",
        "description": "pickle",
        "detail": "pickle",
        "documentation": {}
    },
    {
        "label": "pandas",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pandas",
        "description": "pandas",
        "detail": "pandas",
        "documentation": {}
    },
    {
        "label": "train_test_split",
        "importPath": "sklearn.model_selection",
        "description": "sklearn.model_selection",
        "isExtraImport": true,
        "detail": "sklearn.model_selection",
        "documentation": {}
    },
    {
        "label": "LabelEncoder",
        "importPath": "sklearn.preprocessing",
        "description": "sklearn.preprocessing",
        "isExtraImport": true,
        "detail": "sklearn.preprocessing",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "predict",
        "kind": 2,
        "importPath": "backend.AI_api.api",
        "description": "backend.AI_api.api",
        "peekOfCode": "def predict():\n    try:\n        data = request.get_json()\n        msymptoms = np.array(data[\"symptoms\"], dtype=np.float32).reshape(1, -1) # Make sure data is in correct shape\n        prediction = model.predict(msymptoms)\n        return jsonify({\"prediction\": int(np.argmax(prediction))})\n    except Exception as e:\n        return jsonify({\"error\": str(e)})\nif __name__ == \"__main__\":\n    app.run(port=8000)",
        "detail": "backend.AI_api.api",
        "documentation": {}
    },
    {
        "label": "app",
        "kind": 5,
        "importPath": "backend.AI_api.api",
        "description": "backend.AI_api.api",
        "peekOfCode": "app = Flask(__name__)\nmodel = load_model(\"disease_model.h5\")\n@app.route('/predict', methods=['POST'])\ndef predict():\n    try:\n        data = request.get_json()\n        msymptoms = np.array(data[\"symptoms\"], dtype=np.float32).reshape(1, -1) # Make sure data is in correct shape\n        prediction = model.predict(msymptoms)\n        return jsonify({\"prediction\": int(np.argmax(prediction))})\n    except Exception as e:",
        "detail": "backend.AI_api.api",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "backend.AI_api.api",
        "description": "backend.AI_api.api",
        "peekOfCode": "model = load_model(\"disease_model.h5\")\n@app.route('/predict', methods=['POST'])\ndef predict():\n    try:\n        data = request.get_json()\n        msymptoms = np.array(data[\"symptoms\"], dtype=np.float32).reshape(1, -1) # Make sure data is in correct shape\n        prediction = model.predict(msymptoms)\n        return jsonify({\"prediction\": int(np.argmax(prediction))})\n    except Exception as e:\n        return jsonify({\"error\": str(e)})",
        "detail": "backend.AI_api.api",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "model = load_model(\"disease_model.h5\")\n# Step 2: Load the label encoder\nwith open(\"label_encoder.pkl\", \"rb\") as f:\n    label_encoder = pickle.load(f)\n# Step 3: Input new symptom data (1 = present, 0 = absent)\nnew_symptoms = np.array([[1, 1, 0, 1, 0]])  # Example input\n# Step 4: Make a prediction\nprediction = model.predict(new_symptoms)\npredicted_disease = label_encoder.inverse_transform([np.argmax(prediction)])\n#treatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper diagnosis and treatment.\")",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "new_symptoms",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "new_symptoms = np.array([[1, 1, 0, 1, 0]])  # Example input\n# Step 4: Make a prediction\nprediction = model.predict(new_symptoms)\npredicted_disease = label_encoder.inverse_transform([np.argmax(prediction)])\n#treatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper diagnosis and treatment.\")\nprint(\" Predicted Disease:\", predicted_disease[0])\nprint(\"Treatment: Consult a veterinarian for proper diagnosis and treatment.\")\n\"\"\"import numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras.models import load_model",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "prediction",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "prediction = model.predict(new_symptoms)\npredicted_disease = label_encoder.inverse_transform([np.argmax(prediction)])\n#treatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper diagnosis and treatment.\")\nprint(\" Predicted Disease:\", predicted_disease[0])\nprint(\"Treatment: Consult a veterinarian for proper diagnosis and treatment.\")\n\"\"\"import numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras.models import load_model\nimport pickle\n# Load the trained model",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "predicted_disease",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "predicted_disease = label_encoder.inverse_transform([np.argmax(prediction)])\n#treatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper diagnosis and treatment.\")\nprint(\" Predicted Disease:\", predicted_disease[0])\nprint(\"Treatment: Consult a veterinarian for proper diagnosis and treatment.\")\n\"\"\"import numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras.models import load_model\nimport pickle\n# Load the trained model\nmodel = load_model(\"disease_model.h5\")",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "#treatment",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "#treatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper diagnosis and treatment.\")\nprint(\" Predicted Disease:\", predicted_disease[0])\nprint(\"Treatment: Consult a veterinarian for proper diagnosis and treatment.\")\n\"\"\"import numpy as np\nimport tensorflow as tf\nfrom tensorflow.keras.models import load_model\nimport pickle\n# Load the trained model\nmodel = load_model(\"disease_model.h5\")\n# Load the label encoder",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "model = load_model(\"disease_model.h5\")\n# Load the label encoder\nwith open(\"label_encoder.pkl\", \"rb\") as f:\n    label_encoder = pickle.load(f)\n# Define medicine recommendations for diseases\ntreatment_dict = {\n    \"FMD\": \"Provide anti-inflammatory drugs and ensure proper hydration.\",\n    \"Anthrax\": \"Administer penicillin or oxytetracycline immediately.\",\n    \"Brucellosis\": \"Use doxycycline and streptomycin as prescribed by a vet.\",\n    \"Tuberculosis\": \"Administer rifampin and isoniazid under veterinary guidance.\",",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "treatment_dict",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "treatment_dict = {\n    \"FMD\": \"Provide anti-inflammatory drugs and ensure proper hydration.\",\n    \"Anthrax\": \"Administer penicillin or oxytetracycline immediately.\",\n    \"Brucellosis\": \"Use doxycycline and streptomycin as prescribed by a vet.\",\n    \"Tuberculosis\": \"Administer rifampin and isoniazid under veterinary guidance.\",\n    \"Mastitis\": \"Use intramammary antibiotics like cephalosporins or penicillin.\"\n}\n# Input new symptom data\nnew_symptoms = np.array([[1, 1, 0, 1, 0]])  # Example input\n# Make a prediction",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "new_symptoms",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "new_symptoms = np.array([[1, 1, 0, 1, 0]])  # Example input\n# Make a prediction\nprediction = model.predict(new_symptoms)\npredicted_disease = label_encoder.inverse_transform([np.argmax(prediction)])[0]\n# Get treatment recommendation\ntreatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper treatment.\")\nprint(\"Predicted Disease:\", predicted_disease)\nprint(\"Recommended Treatment:\", treatment)\"\"\"",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "prediction",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "prediction = model.predict(new_symptoms)\npredicted_disease = label_encoder.inverse_transform([np.argmax(prediction)])[0]\n# Get treatment recommendation\ntreatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper treatment.\")\nprint(\"Predicted Disease:\", predicted_disease)\nprint(\"Recommended Treatment:\", treatment)\"\"\"",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "predicted_disease",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "predicted_disease = label_encoder.inverse_transform([np.argmax(prediction)])[0]\n# Get treatment recommendation\ntreatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper treatment.\")\nprint(\"Predicted Disease:\", predicted_disease)\nprint(\"Recommended Treatment:\", treatment)\"\"\"",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "treatment",
        "kind": 5,
        "importPath": "backend.AI_models.test_model",
        "description": "backend.AI_models.test_model",
        "peekOfCode": "treatment = treatment_dict.get(predicted_disease, \"Consult a veterinarian for proper treatment.\")\nprint(\"Predicted Disease:\", predicted_disease)\nprint(\"Recommended Treatment:\", treatment)\"\"\"",
        "detail": "backend.AI_models.test_model",
        "documentation": {}
    },
    {
        "label": "data",
        "kind": 5,
        "importPath": "backend.AI_models.train_model",
        "description": "backend.AI_models.train_model",
        "peekOfCode": "data = pd.read_csv(\"disease_data.csv\")\n# Step 2: Prepare the input (X) and output (y)\nX = data.drop(columns=[\"disease\"])  # Symptoms as input\ny = data[\"disease\"]  # Disease as output\n# Step 3: Convert disease names to numbers\nlabel_encoder = LabelEncoder()\ny = label_encoder.fit_transform(y)  # Converts disease names to numerical values\n# Step 4: Split data into training & testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Step 5: Create the AI model",
        "detail": "backend.AI_models.train_model",
        "documentation": {}
    },
    {
        "label": "X",
        "kind": 5,
        "importPath": "backend.AI_models.train_model",
        "description": "backend.AI_models.train_model",
        "peekOfCode": "X = data.drop(columns=[\"disease\"])  # Symptoms as input\ny = data[\"disease\"]  # Disease as output\n# Step 3: Convert disease names to numbers\nlabel_encoder = LabelEncoder()\ny = label_encoder.fit_transform(y)  # Converts disease names to numerical values\n# Step 4: Split data into training & testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Step 5: Create the AI model\nmodel = keras.Sequential([\n    keras.layers.Dense(10, activation='relu', input_shape=(X_train.shape[1],)),  # Input layer",
        "detail": "backend.AI_models.train_model",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "backend.AI_models.train_model",
        "description": "backend.AI_models.train_model",
        "peekOfCode": "y = data[\"disease\"]  # Disease as output\n# Step 3: Convert disease names to numbers\nlabel_encoder = LabelEncoder()\ny = label_encoder.fit_transform(y)  # Converts disease names to numerical values\n# Step 4: Split data into training & testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Step 5: Create the AI model\nmodel = keras.Sequential([\n    keras.layers.Dense(10, activation='relu', input_shape=(X_train.shape[1],)),  # Input layer\n    keras.layers.Dense(5, activation='relu'),  # Hidden layer",
        "detail": "backend.AI_models.train_model",
        "documentation": {}
    },
    {
        "label": "label_encoder",
        "kind": 5,
        "importPath": "backend.AI_models.train_model",
        "description": "backend.AI_models.train_model",
        "peekOfCode": "label_encoder = LabelEncoder()\ny = label_encoder.fit_transform(y)  # Converts disease names to numerical values\n# Step 4: Split data into training & testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Step 5: Create the AI model\nmodel = keras.Sequential([\n    keras.layers.Dense(10, activation='relu', input_shape=(X_train.shape[1],)),  # Input layer\n    keras.layers.Dense(5, activation='relu'),  # Hidden layer\n    keras.layers.Dense(len(label_encoder.classes_), activation='softmax')  # Output layer\n])",
        "detail": "backend.AI_models.train_model",
        "documentation": {}
    },
    {
        "label": "y",
        "kind": 5,
        "importPath": "backend.AI_models.train_model",
        "description": "backend.AI_models.train_model",
        "peekOfCode": "y = label_encoder.fit_transform(y)  # Converts disease names to numerical values\n# Step 4: Split data into training & testing sets\nX_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n# Step 5: Create the AI model\nmodel = keras.Sequential([\n    keras.layers.Dense(10, activation='relu', input_shape=(X_train.shape[1],)),  # Input layer\n    keras.layers.Dense(5, activation='relu'),  # Hidden layer\n    keras.layers.Dense(len(label_encoder.classes_), activation='softmax')  # Output layer\n])\n# Step 6: Compile the model",
        "detail": "backend.AI_models.train_model",
        "documentation": {}
    },
    {
        "label": "model",
        "kind": 5,
        "importPath": "backend.AI_models.train_model",
        "description": "backend.AI_models.train_model",
        "peekOfCode": "model = keras.Sequential([\n    keras.layers.Dense(10, activation='relu', input_shape=(X_train.shape[1],)),  # Input layer\n    keras.layers.Dense(5, activation='relu'),  # Hidden layer\n    keras.layers.Dense(len(label_encoder.classes_), activation='softmax')  # Output layer\n])\n# Step 6: Compile the model\nmodel.compile(optimizer='adam', loss='sparse_categorical_crossentropy', metrics=['accuracy'])\n# Step 7: Train the model\nmodel.fit(X_train, y_train, epochs=50, batch_size=2)\n# Step 8: Save the trained model",
        "detail": "backend.AI_models.train_model",
        "documentation": {}
    },
    {
        "label": "_Known",
        "kind": 6,
        "importPath": "node_modules.flatted.python.flatted",
        "description": "node_modules.flatted.python.flatted",
        "peekOfCode": "class _Known:\n    def __init__(self):\n        self.key = []\n        self.value = []\nclass _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0",
        "detail": "node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "_String",
        "kind": 6,
        "importPath": "node_modules.flatted.python.flatted",
        "description": "node_modules.flatted.python.flatted",
        "peekOfCode": "class _String:\n    def __init__(self, value):\n        self.value = value\ndef _array_keys(value):\n    keys = []\n    i = 0\n    for _ in value:\n        keys.append(i)\n        i += 1\n    return keys",
        "detail": "node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "parse",
        "kind": 2,
        "importPath": "node_modules.flatted.python.flatted",
        "description": "node_modules.flatted.python.flatted",
        "peekOfCode": "def parse(value, *args, **kwargs):\n    json = _json.loads(value, *args, **kwargs)\n    wrapped = []\n    for value in json:\n        wrapped.append(_wrap(value))\n    input = []\n    for value in wrapped:\n        if isinstance(value, _String):\n            input.append(value.value)\n        else:",
        "detail": "node_modules.flatted.python.flatted",
        "documentation": {}
    },
    {
        "label": "stringify",
        "kind": 2,
        "importPath": "node_modules.flatted.python.flatted",
        "description": "node_modules.flatted.python.flatted",
        "peekOfCode": "def stringify(value, *args, **kwargs):\n    known = _Known()\n    input = []\n    output = []\n    i = int(_index(known, input, value))\n    while i < len(input):\n        output.append(_transform(known, input, input[i]))\n        i += 1\n    return _json.dumps(output, *args, **kwargs)",
        "detail": "node_modules.flatted.python.flatted",
        "documentation": {}
    }
]